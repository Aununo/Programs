from Crypto.Util.number import *

def pollard_p_minus_1(N):
    a = 2
    B = 2
    while True:
        a = pow(a, B, N)
        p = gcd(a - 1, N)
        if p != 1 and p != N:
            return p
        B += 1

n1 = 29993156790273796411588637755401407649619741972315831791586727944419911570896819043688187483218756247767784823799572993962152654560761989054087817767687901
p = pollard_p_minus_1(n1)
q = n1 // p

e = 65537
d = inverse(e, (p-1)*(q-1))

c1 = 28308885699728621592812918494757273712938007912315485487807230648420711341284570451708049371754826651903406663574768899937862287581243099737368091309807825
m1 = pow(c1, d, n1)
flag1 = long_to_bytes(int(m1)).decode()
print(flag1)

import random

hint1 = 397340046977096077577115578026599912881304442662450049334426974861677656259439266980515145452369301652618056238525786266286451780972189318240092026572582216328286841448920434798083168400087303822060653407466964485682775061825982767
hint2 = 42319976894927564843833810567252442522907372281560684051129782019144211533194692653447095916384084531450449319697685128778953472384491084162072476640254892049041007337641419872550411941455264025858397584349456909103991157799852081

def factor(n, e_d):
    while True:
        k = e_d - 1
        g = random.randint(2, n - 1)
        t = k
        while True:
            if t % 2 == 0:
                t //= 2
                x = pow(g, t, n)
                if x > 1 and gcd(x - 1, n) > 1:
                    p = gcd(x - 1, n)
                    return (p, n // p)

n2, r = factor(hint1, hint2)
p2, q2 = factor(n2, hint2)
assert p2 * q2 * r == hint1

phi = (p2 - 1) * (q2 - 1)
d = inverse(e, phi)
m2 = pow(c2, d, n2)
flag2 = long_to_bytes(int(m2)).decode()
print(flag2)